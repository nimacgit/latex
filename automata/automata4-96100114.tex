\documentclass[a4paper]{article}

\usepackage{graphicx}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{blindtext}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{automata,positioning,arrows}



\usepackage{xepersian}
\settextfont{B Roya}
\setlatintextfont{Tahoma}

\title{تمرین چهارم اتوماتا}
\author{نیما بهرنگ 96100114}
\date{\today}	
\begin{document}
\maketitle
\centering{استاد خزایی}


\section*{پرسش ۱}
\begin{enumerate}
\item{}
\item{}
\item{}
\item{}
\item{}
ماشینی می سازیم که در هر گام یک حرف را به جای مناسبش می برد.
\begin{latin}
$Q = {q_0, q_a, q_b, q_c, q_1}$\\

$\forall x \in \{a,b,c\} \delta(q_0,x)=(q_x,Z,L)$\\
$\forall x \in \{a,b,c\}, w \in \{a,b,c,Z\}  \delta(q_x,w) = (q_x,w,L)$\\
$\forall x \in \{a,b,c\} \delta(q_x,B)=(q_1,x,R)$\\
$\forall x \in \{a,b,c\} \delta(q_1,x)=(q_1,x,R)$\\
$\delta(q_1,Z) = (q_0,Z,R)$\\
$\delta(q_0,B) = (f,B,L)$\\
$\delta(f,Z) = (f,B,L)$\\
$\delta(q_0,Z) = (q_0,Z,R)$\\

\end{latin}
\end{enumerate}
\pagebreak
\section*{پرسش ۲}

\begin{enumerate}
\item{}
اعداد اول حداکثر ۱۰۰ رقمی محدود است پس ماشین تورینگی وجود دارد که همه آنها را بررسی کن و بنویسد و متوقف شود.پس بازگشتی است\\
\item{}
چون نمی دانیم تعداد اعداد دوقلو متناهی است یا نا متناهی پس یک الگوریتم نیاز است و بازگشتی برشمردنی است\\
\item{}
بازگشتی برشمردنی است. با الگوریتم اعداد پیدا کردن عدد اول می توان فهمید که اول است یا خیر پس برایش الگوریتم داریم.\\
\item{}
بازگشتی است.به دو دلیل\\
اگر 
\lr{$L_1$}
تهی باشد پس آن زبان یک زبان بازگشتی برشمردنی است.\\
دوم اگر یک زبان بازگشتی برایش باشد، چون
\lr{$L_2$}
نیز بازگشتی است، برای 
\lr{$L_1$}
نیز یک ماشین می توان ساخت که معادل زبان بازگشتی باشد و این با فرض مسئله تناقض دارد.
\end{enumerate}

\pagebreak
\section*{پرسش ۳}
می دانیم ماشین های تورینگی داریم که یک رشته باینری را با عددی جمع کنند و همچنین ماشینی که رشته را کپی کند.
حال چون بشریت این رمان ها را در زمان محدود نوشته پس تعداد آنها ثابت است و حجم باینری شده بزرگترین آنها نیز تعریف شده و مقدار ثابتی است مثل \lr{k} بیت\\
حال کافی است بارشته 
\lr{k}
تا صفر شروغ کنیم و یکی یکی به آن بیفزاییم، این گونه تمام اعداد حداکثر
\lr{k}
بیتی را می سازیم.\\
برای این کار ابتدای هر گام، یکی کپی از عدد قبلی را در ادامه رشته کپی می کنیم و سپس آن قسمت را یکی می افزاییم
\pagebreak

\section*{پرسش ۴}
اگر فرض کنیم چنین ماشینی وجود دارد،می توانیم به روش زیر ماشینی بسازیم که جواب قسمت اول باشد که می دانیم وجود ندارد.\\
با استفاده از ماشین تشخیص 
\lr{\#}
و دادن رشته ای متناظر با ورودی دلخواه به صورت زیر،جواب مسئله اول را می دهیم.\\
در ورودی هر 
\lr{\#}
را با کاراکتری که در زبان نیست تعویض می کنیم تا تمام
\lr{\#}
حذف شوند.
حال در تعریف ماشین داده شده در ورودی، استیتی را که به فاینال می رود را این گونه بازنویسی می کنیم\\
\lr{
$\delta(q,x) = (F, X, Dir) ---> \delta(q,x) = (F, \#, Dir)
$
}\\
پس تنها زمانی که فاینال می رویم که 
\lr{\#}
دیده ایم و هر وقت به فاینال برویم قطعا 
\lr{\#}
می بینیم
پس این ماشین درصورت وجود جواب مسئله اول را به صورت بازگشتی می دهد که با فرض مسئله تناقض دارد.
\pagebreak

\section*{پرسش ۵}
\begin{enumerate}[label=\Alph*]
\item{)}
غلط زیرا ماشین جهانی هر ماشین تورینگی را می پذیرد و خود یک ماشین تورینگ است پس خود را می پذیرد.
\item{)}
غلط چون هر دو شمارا تا هستند(نا متناهی) و این یعنی هر دو با اعداد طبیعی هم ارزش و هم اندازه هستند پس تعدادشان یکی باید باشد زیرا همان رابطه هم ارزی که هر یک را با اعداد طبیعی هم ارز می کند را می توان استفاده کرد تا این دو را هم ارز نشان داد.
\item{}
غلط زیرا طبق اثبات های قبلی می دانیم زبان همه ماشین هایی که خودشان را می پذیرند بازگشتی برشمردنی است اما متمم آنها نیست.
\end{enumerate}
\pagebreak

\section*{پرسش ۶}
جزییات کامل این اثبات را در صفحه ۳۴۸ کتاب اصلی درس می توانید ببینید.\\
این سوال را با فرض برابری ماشین چند نواره با هد های متفاوت و قابلیت ثابت ماندن هد ها حل می کنیم.\\
ماکزیمم اندازه مجموعه
\lr{$|\delta(q,a)| = k$}
باشد. یک ماشین قطعی با دو نوار در نظر می گیریم که نوار اول همان رشته اصلی است و در نوار دوم جزییات هر گام را به صورت کامل می نویسد.این اطلاعات هر گام شامل وضعیت نوار اصلی و موقعیت هد است.حال در هر مرحله یکی یکی این جزئیات را می خواند (موقعیت کنونی را هم با یک مارک می توان نگه داریم) و چون در گام بعدی به تعدادی حالت ممکن است برود، پس کافی است هر حالت که به آن می رود را در انتهای نوار دوم اضافه کند تا زمانی در آینده آن را بپیماید\\
با این کار
\lr{BFS}
روی حالت ها زده ایم پس اگر در ماشین غیر قطعی با تعداد متناهی حالت 
\lr{m}
به حالت فاینال رسیده باشیم در این حالت نیز با حداکثر
\lr{$m \times k^m$}
تا حرکت در ماشین ما، قطعا به همان حالت می رسد که این عدد تعداد 
راس های درختی است که ما روی آن
\lr{BFS}
زده ایم.\\
بلعکس اگر ما به حالت فاینال رسیده باشیم پس تعدادی حرکت در ماشین غیر قطعی وجود دارد که به حالت فاینال برسد.
\pagebreak

\section*{پرسش ۷}
قدرت ماشین یک طرفه کمتر مساوی ماشین دوطرفه است زیرا اگر همان مشخصات و توابع و کاراکتر های یک طرفه را روی دوطرفه اجرا کنیم به همان جواب یک طرفه خواهیم رسید.\\
حال اگر یک ماشین دو طرفه داشته باشیم،می توانیم به صورت زیر برایش یک ماشین یک طرفه معرفی کنیم.\\
هر گاه این ماشین به سمت چپ حرکت کرد به طوری که از اندازه نوار خارج می شد، یک کپی از کل نوار را در ادامه رشته کنونی پیاده می کنیم(برای این کار ماشین تورینگ کپی کن را قبلا ساخته ایم)سپس تمام کاراکتر های رشته قبلی را 
\lr{B}
می گذاریم پس رشته ما به اندازه طولش به سمت راست منتقل می شود و می تواند باز هم به سمت چپ برود\\
برای پیاده کردن ماشین کپی کننده کافی است تا از کاراکتری مثل ! استفاده کنیم و تمام رشته همواره بین دوتا !! باشد یعنی 
\lr{!asdasd!}
حال برای کپی کردن کافی است محتوای داخل ! را کپی کنیم و دوباره ! را در ابتدا و انتهای رشته بگذاریم.\\
\pagebreak
\section*{پرسش۸}
کافی است نشان دهیم با ماشین دو پشته ای می توان هر حرکت ماشین تورینگ را شبیه سازی کرد و همچنین با ماشین تورینگ هر حرکت ماشین دوپشته ای.\\
\begin{enumerate}
\item{}
در ماشین تورینگ ما در خانه ای هستیم و تعداد حرف در سمت راست پوینتر و تعدادی در سمت چپ است باقی خالی هستند
\lr{B}
.
حال کافی است تا حروف سمت چپ به همراه حرفی که پوینتر روی آن است را در استک اول و حروف سمت راست را در استک دوم بگذاریم به این صورت که\\
\lr{abcdeYfghi : abcd*(e)fghi}\\
ما در خانه
\lr{*}
هستیم و استک ها به ترتیب این گونه هستند:\\
\lr{abcde -> Top}\\
\lr{ihgf -> Top}\\
حال با هر حرکت ماشین تورینگ کافی است تا محتوی روی استک ها را درست کنیم یعنی ابتدا از هر دو استک یک کاراکتر برداریم و اگر به سمت راست رفتیم کاراکتری که ماشین تورینگ جایگزین خانه فعلی کرده را به استک اول افزوده و کاراکتری که روی استک دوم بود را به استک اول اضافه کنیم. اگر به چپ رفتیم هم فقط کافی است کاراکتری که جایگزین شده را به استک دوم اضافه کنیم.پس تمام حرکات ماشین تورینگ قبل معادل سازی است.\\
\item{}
حال برای شبیه سازی ماشین دو پشته ای کافی است همانند قسمت قبل محتوی استک ها را معادل کنیم به این صورت که با یک 
\lr{\#}
روی نوار، بین محتوی استک اول و دوم تمایز قائل شویم\\
\lr{abcd ->Top}\\
\lr{efgh -> Top}\\
\lr{dcba\#efgh}\\
حال با تغییر محتوای ابتدایی هر استک،کافی است از سر و ته نوار کاراکتر کم و زیاد کنیم.
\end{enumerate}
\pagebreak

\end{document}