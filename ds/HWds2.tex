\documentclass[a4paper]{article}

\usepackage{graphicx}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{blindtext}
\usepackage{listings}



\usepackage{xepersian}
\settextfont{B Roya}
\setlatintextfont{Tahoma}

\title{تمرین دوم ساختمان داده}
\author{نیما بهرنگ 96100114}
\date{\today}	
\begin{document}
\maketitle
\centering{استاد فروغمند}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
\section*{تکراری}

\begin{latin}	
\begin{lstlisting}
for(int i = 1; i <= n + 1; i++){
	v = a[i];
	if(v != i){
		if(a[v] == v)
			return v;
		else{
			swap(a[v], a[i]);
			i--;
		}
	}
}
\end{lstlisting}
\end{latin}
الگوریتم بالا روی خانه های جدول جلو می رود و هر عدد را در خانه ی خودش می گذارید یعنی
\lr{i -> a[i]}
و اگر در خانه 
\lr{a[i]}
مقدار درستش باشد، و ما باید همان مقدار را دوباره در آن خانه بگذاریم یعنی از عدد
\lr{i}
تکراری داریم


\newpage
\section*{پالیندروم}
\begin{latin}
\begin{lstlisting}
cur = list.head
next = cur.next()
for(int i = 0; i < n/2; i++){
	temp = next.next();
	next.next() = cur;
	cur = next;
	next = temp;
}
if(n % 2 == 1)
	next = next.next()
while(cur != list.head){
	if(cur.v != next.v)
		return not;
	cur = cur.next();
	next = next.next();
}
return true;
\end{lstlisting}
\end{latin}
الگوریتم فوق نصف اول لیست را با اوردر حافظه ۱ به صورت برعکس لیست می کند و سپس روی نصف اول و نصف دوم حرکت می کند و چک می کند که برابر باشند

\newpage

\section*{مولد}

جواب این مسيله همان عدد کاتالان است به این صورت که با هر بار اضافه کردن یکی به سمت راست برویم و با هربار حذف کردن، یکی به سمت بالا برویم که طبق فرض کاتالان و فرض مسئله تعداد بالاها نمی تواند از تعداد راست ها بیشتر شود
پس جواب انتخاب 
\lr{n}
از
\lr{2n}
تقسیم بر
\lr{n + 1}
است

\begin{latin}
$\dfrac{(
\begin{tabular}{c c} 
 2n \\ [0.5ex] 
 n
 \end{tabular}
)}{n+1}$
 \end{latin}
\newpage
\section*{هرمی}
تابعی بازگشتی تعریف می کنیم که 
\lr{x, k}
می گیرد و تعداد اعداد بزرگتر از 
\lr{x}
را بر می گرداند ولی با این شرط که اگر بیشتر از 
\lr{k}
تا بود،دیگر ادامه نمی دهد و فقط باز می گردد\\
حال این تابع را روی یک راس که صدا می کنیم اگر خود راس بزرگ تر باشد،
\lr{k}
را یکی کم کرده و سپس بچه سمت چپ خود را با
\lr{(x, k-1)}
صدا می کند
در غیر اینصورت خود آن راس و تمام بچه هایش کوچکتر از
\lr{x}
هستند و فقط کافی است صفر را به پدرش بازگرداند\\
پس در حال بزرگتر بودن باید
مقداری که می گیرد را از 
\lr{k-1}
کم کند
و مقدار حاصل را برای بچه دیگر خود فراخوانی  کند
یعنی
\lr{x, k - 1 - r}\\
حال جمع مقدار خود و دو بچه اش را برای پدرش(بازگشتی) می فرستد.\\
اگر راسی
\lr{k}
\\اش صفر بود،دیگر کاری نمی کند و باز می گردد.
اگر مقدار تابع به ازای راس ریشه صفر باشد،جواب مسئله مثبت وگنه منفی است و ما نیز 
همچنین در هر گام ما مقدار 
\lr{k}
را یکی کم می کنیم و یا اگر تغییر نکند از آنجا دیگر ادامه نمی دهیم
پس به ازای هر بار کم کردن حداکثر دوبار به حالت بازگرداندن صفر ممکن است برخورد کنیم
پس در مجموع حداکثر 
\lr{3*k}
عملیات انجام می دهیم
که از 
\lr{O(k)}
است
\newpage
\section*{نیمه مرتب}
اعداد را 
\lr{k}
تا 
\lr{k}
تا 
جدا می کنیم\\
حال 
\lr{2*k}
تای اول را با مرج سورت سورت می کنیم\\
حال 
\lr{k}
تای دوم و سوم را باهم سورت می کنیم و به همین ترتیب تا انتها
چون هر عدد حداکثر
\lr{k}
تا با جایگاهش فاصله دارد پس همواره در جایگاه واقعیش قرار می گیرد زیرا طبق الگوریتم ما با 
\lr{k}
تا بعد و قبل خود مقایسه و مرتب می شود\\
اوردر الگوریتم برابر
\lr{
$\dfrac{n}{k} * k lg(k) = n lg(k)$
}
است\\
اگر عددی در جایگاه درست خود قرار نگیرد،باید بیشتر از 
\lr{k}
تا با جایگاهش فاصله داشته باشد که با فرض مسئله در تناقض است

\newpage

\section*{مرتب سازی}	
اعداد را با
\lr{a. b. c, d, e}
نمایش  می دهیم
ابتدا دو عضو اول را با یک مقایسه مرتب می کنیم.
حال عضو سوم را با عضو چهارم مقایسه می کنیم.
با توجه به تقارن عملیات ها، با این کار به یک چهارم جایگشت های ممکن می رسیم
فرض می کنیم ترتیب درست آنها
\lr{a,b}
و
\lr{c,d}
باشد\\
حال با مقایسه
\lr{a, c}
باز به طور متقارن به نصف جایگشت ها می رسیم زیرا تنها کافیست لیبل
\lr{a,c}
و
\lr{b,d}
تعویض کنیم تا به نیمه دیگر برسیم\\
حال ترتیب درست حروف به شکل های زیر باشد\\
\lr{c,a,b,d}\\
\lr{c,a,d,b}\\
\lr{c,d,a,b}\\
حال اگر
\lr{a, e}
را مقایسه کنیم
به دو مجموعه
\begin{enumerate}
\item{}
\lr{c,a,e,b,d}\\
\lr{c,a,b,e,d}\\
\lr{c,a,b,d,e}\\
\lr{c,a,d,b,e}\\
\lr{c,a,e,d,b}\\
\lr{c,d,a,e,b}\\
\lr{c,d,a,b,e}\\
سپس با مقایسه
\lr{b,e}
به دو دسته می رسیم
\begin{enumerate}
\item{}
\lr{c,a,e,b,d}\\
\lr{c,a,e,d,b}\\
\lr{c,a,d,e,b}\\
\lr{c,d,a,e,b}\\
وبا مقایسه
\lr{e,d}
به دو دسته دوتایی می رسیم که جواب اولی با
\lr{b,d}
و دومی با 
\lr{a,d}
یکتا مشخص می شود

\item{}
\lr{c,a,b,e,d}\\
\lr{c,a,b,d,e}\\
\lr{c,a,d,b,e}\\
\lr{c,d,a,b,e}\\
وبا مقایسه
\lr{b,d}
به دو دسته دوتایی می رسیم که جواب اولی با
\lr{d,e}
و دومی با 
\lr{d,a}
یکتا مشخص می شود

\end{enumerate}


\item{}
\lr{e,c,a,b,d}\\
\lr{c,e,a,b,d}\\
\lr{e,c,a,d,b}\\
\lr{c,e,a,d,b}\\
\lr{e,c,d,a,b}\\
\lr{c,e,d,a,b}\\
\lr{c,d,e,a,b}\\
سپس با مقایسه
\lr{c,e}
به دو دسته می رسیم
\begin{enumerate}
\item{}
\lr{e,c,a,b,d}\\
\lr{e,c,a,d,b}\\
\lr{e,c,d,a,b}\\

وبا مقایسه
\lr{b,d}
به دو دسته می رسیم که یکی یکتا و دیگری با مقایسه
\lr{d,a}
یکتا مشخص می شود

\item{}
\lr{c,e,a,b,d}\\
\lr{c,e,a,d,b}\\
\lr{c,e,d,a,b}\\
\lr{c,d,e,a,b}\\
وبا مقایسه
\lr{a,d}
به دو دسته دوتایی می رسیم که جواب اولی با
\lr{d,b}
و دومی با 
\lr{d,e}
یکتا مشخص می شود

\end{enumerate}

\end{enumerate}
\newpage

\section*{انتخابگر}	
همان کد الگوریتم مرتب سازی سریع را استفاده می کنیم ولی اینبار بعد از پارتیشن کردن،اگر محور،
\lr{k}
امین عدد بود یعنی 
\lr{k - ۱}
عدد کمتر از آن بود
همان محور را بازمی گردانیم
در غیر اینصورت اگر کمتر بود
مثلا 
\lr{r}
امین عدد بود، در بین بزرگتر هایش به دنبال
\lr{k-r}
امین می گردیم
در غیر اینصورت بین کوچکتر هایش به دنبال 
\lr{k}
امی می گردیم\\
برای اوردر برنامه کافیست روی اینکه مجور ما در حالت مرتب شده چندمین است حالت بندی کنیم\\
اگر \\
\lr{k<r<n}\\
 را انتخاب کنیم باید تابع را به ازای \\
\lr{f(r - 1, k)}\\
صدا کنیم و در غیر اینصورت به ازای\\
\lr{f(n - r, k - r)}\\
که اگر استقرایی بخواهیم حل کنیم می شود امید ریاضی\\
\lr{E = 
$\dfrac{n-1}{n}+ \dfrac{n-2}{n}+ ... \dfrac{1}{n} = \dfrac{n}{2}$
}\\
که از اوردر خواسته شده است
\newpage


\end{document}
