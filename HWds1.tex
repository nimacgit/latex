\documentclass[a4paper]{article}

\usepackage{graphicx}
\usepackage{multirow}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{blindtext}
\usepackage{listings}



\usepackage{xepersian}
\settextfont{B Roya}
\setlatintextfont{Tahoma}

\title{تمرین اول ساختمان داده}
\author{نیما بهرنگ 96100114}
\date{\today}	
\begin{document}
\maketitle
\centering{استاد فروغمند}
\section*{سوال ۱}
\begin{enumerate}
\item{}
طبق گفته کتاب
$lim(\dfrac{log(n)^b}{n^a}) = 0 \:  | \:  a > 0$
پس
$\sqrt{n} = \Omega(log(n))$
\item{}
$nlog(n) = \Theta(log(n!))$
\\
$log(n!) = log(1) + log(2) + ... + log(n) \leq nlog(n)$
\\
$log(n!) \geq c_1 \times \dfrac{n}{2} \times log(\dfrac{n}{2}) \geq 2 \times \dfrac{n}{2}log(n) \geq nlog(n) \: | \: n \geq 10$

\item{}
$(1 + \dfrac{1}{2} + \dfrac{1}{3} + \dfrac{1}{4} + ... + \dfrac{1}{n}) = \Theta log(n)$
\\
$A = (1 + \dfrac{1}{2} + \dfrac{1}{3} + \dfrac{1}{4} + ... + \dfrac{1}{n})$
\\
$A \leq (1 + \dfrac{1}{2} + \dfrac{1}{2} + \dfrac{1}{4} + \dfrac{1}{4} + \dfrac{1}{4} + ... + \dfrac{1}{log(n)} \leq log(n) \times 1 = log(n)) $
\\
$A \geq (\dfrac{1}{2} + \dfrac{1}{2} + \dfrac{1}{4} + \dfrac{1}{4} + \dfrac{1}{4} + \dfrac{1}{4} + ... \dfrac{1}{log(n)} \geq log(n)$

\item{}
$\sqrt[10000]{n} = \Omega(log(n))$
\\
به طور مشابه برای الف و طبق گفته کتاب
\end{enumerate}
\newpage
\section*{سوال ۲}
\begin{enumerate}
\item{}
\lr{n}
بار مغیر ما زیاد می شود پس کلا
$\Theta(n)$
\item{}
به اندازه
 \lr{log(n)}
 بار حلقه اجرا می شود زیرا هر بار نصف می شود و هر بار دو عملیات درونش انجام می شود پس
$\Theta(n)$ 

\item{}
همان دنباله فیبوناچی است که کوچکتر از حالتی است که دوبار جمله قبلی صدا شود یعنی
$f(n-1) + f(n-2) \leq 2*f(n-1) \Rightarrow$
\\
$O(2^n)$

\item{}
همان تابع
\\
$T(n) = T(\dfrac{n}{2}) + n$
\\
که حاصل آن مجموع :
\\
$n + \dfrac{n}{2} + \dfrac{n}{4} + ...$
\\
$\Theta(n)$
\\
طبق مسأله حل شده در کتاب
\item{}
همان تابع
\\
$T(n) = T(\dfrac{n}{3}) + n$
\\
که حاصل آن مجموع :
\\
$n + \dfrac{n}{3} + \dfrac{n}{9} + ...$
\\
$\Theta(n)$
\\
چون از جمله دوم به بعد مجموعا برابر
\lr{n}
نمی شوند پس در کل از دوبرابر آن کمتر و از خود
\lr{n}
بیشترند
\item{}
دو تا حلقه که هر کدام به اندازه ورودی انجام می شوند و متغیر را زیاد می کنند و مجموعا
\lr{$n^2$}
عملیات انجام می شود
\\
$\Theta(n^2)$
\item{}
حلقه اول
\lr{$\dfrac{n}{2}$}
\\حلقه دوم
\lr{log(n)}
\\حلقه سوم
\lr{log(n)}
\\و مجموعا\\
$\dfrac{n}{2} \times log(n) \times log(n) = \Theta(nlog^2(n))$

\item{}
\lr{t}
به صورت زیر زیاد می شود
\\
$1 + 1 + 2 + 3 + 4 + ... x = \dfrac{x\times(x-1)}{2} + 1 = n \Rightarrow$
\\
$x = \sqrt{2 \times n}$
\\
پس مجموعا به اندازه رادیکال ورودی عملیات انجام می شود\\
$\Theta(\sqrt[2]{n})$

\item{}

تابع به اندازه ورودی عملیات انجام می دهد و متن اصلی برنامه آن را به ازای مقادیر زیر صدا می کند پس کلا به تعداد
$\dfrac{n}{2} + \dfrac{n}{3} + ... \dfrac{n}{n}$
عملیات انجام می شود
\\
که طبق اثبات کتاب مجموع 
$\dfrac{1}{i}$
همان 
\lr{log(n)}
است به صورت انتگرالی
پس مجموعا می شود
\\
$\Theta(nlog(n))$
\end{enumerate}
\begin{latin}
\section*{multiplying}
\end{latin}
\begin{enumerate}

\item{}
به طور مشابه هر چند جمله ای را به دو بخش می شکنیم\\
یکی با درجات بیش از 
\lr{$\dfrac{n}{2}$}
یکی با درجات کمتر\\
و حاصل مورد نظر برابر ضرب هر یک از قسمت های چند جمله ای اول در چند 
جمله ای دوم است\\

$P_1 = A1 + A2, P_2 = B1 + B2$\\
$P_1 \times P_2 = A1 \times B1 + A1 \times B2 + A2 \times B1 + A2 \times B2$\\


$T(n) = 4\times T(\dfrac{n}{2}) + n$\\

که طبق قضیه مستر\\

$n = O(n^{2-\epsilon}) \Rightarrow T(n) = \Theta(n^2) $
\\
\item{}
اگر چند جمله ای اول به 
\lr{A1, A2}
و دومی به 
\lr{B1, B2}
تقسیم شوند
چون درجات 
\lr{$B_2 \times A_1 and A_2 \times B_1$}
با هم برابر است می توان \\

$C_1 = A_1 \times B_1$\\
$C_2 = A_2 \times B_2$\\
$C_3 = (A_1 + A_2) \times (B_1 + B_2)$\\
$A_1 \times B_2 + A_2 \times B_1 = C_3 - C_1 - C_2$\\
و به این صورت ضرایت تک تک درجات بدست می آیند ولی ۳ بار ضرب 
\lr{n/2}
تایی در هم انجام شده

$T(n) = 3*T(\dfrac{n}{2}) + O(n)$
\\
که طبق قضیه مستر\\
$f(n) = O(n^{\log_{2}{3}}) \Rightarrow T(n) = \Theta (n^{\log_2{3}}) $

\end{enumerate}
\newpage
\begin{latin}
\section*{fibonacci}
\end{latin}
\begin{enumerate}
\item{}
$T(n) \leq 2 \times T(n-2) \Rightarrow T(n) = \Omega(2^{\dfrac{n}{2}}) = \Omega\sqrt{2}^n$\\
$T(n) \geq 2 \times T(n-1) \Rightarrow T(n) = O(2^n)$
\\
پس رشد تابع گفته شده بین دو تابع نمایی می باشد پس خود آن نیز نمایی است

\item{}
خانه های بالا راست و پایین چپ با هم برابر و برابر عدد فیبو ناچی توان منهای یک اند. عدد چپ بالا برابر عدد فیبو ناچی برابر توان است و عدد راست پایین عدد فیبوناچی توان منهای دو است.

با هر بار ضرب این ماتریس می توان عدد فیبوناچی بعدی را پیدا کرد و هزینه آن برابر عملیات است
پس با
\lr{8 * n}
عملیات می توان عدد فیبوناچی \lr{n} ام را پیدا کرد که نسبت به ورودی خطی است و از
$\Theta(n)$
است

\end{enumerate}
\newpage
\begin{latin}
\section*{inversion}
\end{latin}
$ E[inv] = E[\Sigma_{i = 0}^{i = n}{\Sigma_{j = i + 1}^{j = n}inv(i,j)}]$
\\
$ E[inv] = \Sigma_{i = 0}^{i = n}{\Sigma_{j = i + 1}^{j = n}E[inv(i,j)]}$
\\
$ E[inv] = \Sigma_{i = 0}^{i = n}{\Sigma_{j = i + 1}^{j = n}1\times PR(i,j)}$\\
$PR(i,j) = \dfrac{1}{2}$\\
چون به ازای هر حالت آن می توان با جابجا کردن جای آن دو به حالتی رسید که اینورژن نباشند و به دلیل این تقارن و برابر بودن شانس آن ها به دلیل تصادفی بودن هر جایگشت تعداد جواب های خوب با بد برابر و احتمال این رویداد یک دوم است\\

$ E[inv] = \Sigma_{i = 0}^{i = n}{\Sigma_{j = i + 1}^{j = n}\dfrac{1}{2}}$\\
$ E[inv] = \dfrac{n\times (n-1)}{2} \times \dfrac{1}{2} = \dfrac{n\times (n-1)}{4}$ 

\newpage
\begin{latin}
\section*{divide}	
\end{latin}
برای این کار ابتدا به ازای هر خانه مشخص می کنیم موقعیت عدد  آن خانه   کجاست یعنی به ازای خانه شماره
\lr{i}
عدد
\lr{i}
در کدام خانه است

\begin{enumerate}
\item{لم۱}
چون با مرتب کردن هر زیر آرایه باید همه مرتب شوند پس هم خانه 
\lr{i}
و هم خانه ای که عدد
\lr{i}
در آن است باید در یک زیر بازه باشند
\end{enumerate}
حال شروع می کنیم خانه اول را نگاه می کنیم و اولین زیر بازه ما خانه اول تا خانه ای است که عدد یک در آن است و به تمام خانه هایی که در این میان است نیز نگاه می کنیم و اگر اعداد آنها در بیرون از زیر آرایه ما بود. زیر آرایه ما تبدیل می شود به زیر آرایه ای از خانه اول تا دورترین خانه ای که عددی از خانه های این بین در آن است
یعنی
\begin{latin}
B[i] : number of cell that number i is in\\

for i = 1 to max1\\

max1 = max(max1, b[i])\\

\end{latin}
حال این زیر آرایه شامل اعداد متوالی است زیرا حتما شامل اعداد یک تا
\lr{k}
است و همچنین 
\lr{k}
خانه دارد پس فقط اعداد یک تا 
\lr{k}
در آن است
و همچنین با مرتب کردن انها حتما آن تیکه از آرایه مرتب می شود\\

حال به سراغ خانه 
\lr{k + 1}
می رویم و همین الگوریتم را پیاده می کنیم
\\
در اصل ما به دنبال کوچک ترین مولفه ها می رویم و می دانیم که هر جواب دیگری برای این مسئله باید طبق لم گفته شده\lr{,} زیر آرایه گفته شده توسط ما را نیز داشته باشد\\

\begin{latin}
get A\\
C : ansers of problem\\
for(int i = 0; i < n; i++)\\
B[A[i]] = i\\
B[i] : number of cell that number i is in\\
for k = 0 to n-1 : \{\\
	max1 = B[k]\\
	for i = k to max1:\{\\
		max1 = max(max1, b[i])\\
		\}\\
	C[cnt++] = max1\\
	k = max1+1\\
	\}\\
\end{latin}
\newpage
\begin{latin}
\section*{couple}	
\end{latin}
از روش استفاده از دو پوینتر استفاده می کنیم

ابتدا با مرج سورت آرایه را مرتب می کنیم که 
\lr{nlogn}
است\\
حال اولین خانه ای(سمت چپ ترین) را پیدا می کنیم که جمعش با خانه اول آرایه بیشتر از 
\lr{k}
شود
فرض کنیم خانه 
\lr{i}
باشد
حال اگر جمع اولی با 
\lr{i - 1}
\lr{, k}
بود که جواب است در غیر این صورت خانه 
\lr{i}
را با خانه دوم مقایسه می کنیم و آنقدر زیادش می کنیم که مثل خانه اول بزرگتر مساوی 
\lr{k}
شود و به همین ترتیب با باقی خانه ها\\
می دانیم که اگر جمع دو عدد 
\lr{k}
شود در الگوریتم ما عدد کوچکتر را با آن مقایسه کرده ایم تا به نقطه مساوی یا بزرگتر برسیم\\
پس در الگوریتم ما نیز ظاهر می شود\\
\begin{latin}
sort\\
int j = 0;\\
for(int i = 0; i < n; i++)\\
while(a[i] + a[j] < k)\{\\
k++\\
\}\\
if(j < n \&\& a[i] + a[j] == k)\{\\
return i, j\\
\}\\
\end{latin}
همان طور که مشخص است حلقه اول به اندازه ورودی و حلقه دورونی آن مجموعا به اندازه ورودی بار عملیات انجام می دهند پس\\
$f(n) = O(nlog(n)) +O(n) = O(nlog(n))$
\newpage
\begin{latin}
\section*{minesweeper}
\end{latin}
از اولین خانه شروع و به طول ابتدا ۱ سپس ۲ سپس ۴ سپس ۸ و .... جلو می رویم و چک می کنیم یعنی خانه ۱ سپس ۲ تا ۴ سپس ۴ تا ۸ و ....\\
حال اگر بمب را بیابیم تا اینجای کار به اندازه
\lr{log(n)}
عملیات انجام داده ایم
حال باید در یک بازه به طول حداکثر 
\lr{n / 2}
به دنبال بمب بگردیم که با روش حذف کردن نصف در  
\lr{log(n)}
ممکن است\\
به این صورت که در بازه ای که بمب بود ابتدا نصف سمت چپ را چک می کنیم و می فهمیم بمب در کدام نصفه است\\
حال نصف آن نصفه و به همین ترتیب تا بلاخره به یک خانه برسیم\\
پس در مجموع
\lr{2*log(n)}
عملیات نیاز است که از 
\lr{o(n)}
است

\newpage
\begin{latin}
\section*{triangle}
\end{latin}
همانند سوال قبل ابتدا مرتب می کنیم و سپس دو ضلع کوچک تر را فیکس و ضلع سوم را در اوردری کم میابیم

\begin{latin}
sort a[]\\
for(int i = 0; i < n - 2; i++)\{\\
l = i + 2;\\
for(int j = i + 1; j < n - 1; j++)\{\\
while(a[i] + a[j] > a[l])\{\\
l++
\}\\
ans += l - j\\
\}\\
\}\\
\end{latin}

اوردر این برنامه یک مرتب سازی ان لاگ ان است بعلاده دو عدد حلقه از صفر تا 
\lr{n}
که به ازای هر بار که کوچکترین ضلع تغییر کند یک حلقه به اندازه حداکثر
\lr{n}
روی
\lr{l}
انجام می گیرد و در مجموع\\
$nlogn + n^2 + n^2 = O(n^2)$\\
عملیات داریم\\
چون 
\lr{l}
نشان دهنده خانی است که دیگر نمی توان تشکیل مثلث بدهد\\
پس با تمام قبلیهایش می توان مثلث ساخت
\newpage


\end{document}
